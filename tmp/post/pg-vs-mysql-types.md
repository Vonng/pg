# PostgreSQL与MySQL数据类型的差异

List of available data types can be reached also by using psql's internal slash command `\dT`.

| MySQL                                                        | PostgreSQL                                                   | ANSI Standard SQL                                            | comments                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `TINYINT SMALLINT MEDIUMINT BIGINT`                          | `SMALLINT SMALLINT INTEGER BIGINT `                          | `INTEGER INTEGER INTEGER NUMERIC(20) `                       | see [[2\]](http://www.postgresql.org/docs/8.1/interactive/datatype.html#DATATYPE-INT); `integer` size in PostgreSQL is 4 Bytes signed (-2147483648 – +2147483647) |
| `TINYINT UNSIGNED SMALLINT UNSIGNED MEDIUMINT UNSIGNED INT UNSIGNED BIGINT UNSIGNED ` | `SMALLINT INTEGER INTEGER BIGINT NUMERIC(20) `               | `INTEGER INTEGER INTEGER NUMERIC(10) NUMERIC(20) `           | SQL doesn't know `UNSIGNED`, all numbers are signed.         |
| `FLOAT FLOAT UNSIGNED `                                      | `REAL REAL `                                                 | `FLOAT4 FLOAT4 `                                             |                                                              |
| `DOUBLE`                                                     | `DOUBLE PRECISION`                                           | `FLOAT8`                                                     |                                                              |
| `BOOLEAN`                                                    | `BOOLEAN`                                                    | `BOOLEAN`                                                    | MySQL Booleans are an alias for TINYINT(1); PostgreSQL doesn't auto-convert numbers into booleans. |
| `TINYTEXT TEXT MEDIUMTEXT LONGTEXT `                         | `TEXT TEXT TEXT TEXT `                                       | `TEXT TEXT TEXT TEXT `                                       |                                                              |
| `BINARY(*n*) VARBINARY(*n*) TINYBLOB BLOB MEDIUMBLOB LONGBLOB ` | `BYTEA BYTEA BYTEA BYTEA BYTEA BYTEA `                       | `BIT(*n*) BIT VARYING(*n*) TEXT TEXT TEXT TEXT `             |                                                              |
| `ZEROFILL`                                                   | `not available`                                              | `not available`                                              |                                                              |
| `DATE TIME DATETIME TIMESTAMP `                              | `DATE TIME [WITHOUT TIME ZONE] TIMESTAMP [WITHOUT TIME ZONE] TIMESTAMP [WITHOUT TIME ZONE] ` | `DATE TIME TIMESTAMP TIMESTAMP `                             |                                                              |
| `*column* SERIAL `equals to:`*column* BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE `or:`*column* INT DEFAULT SERIAL `equals to:`*column* INT NOT NULL AUTO_INCREMENT UNIQUE ` | `*column* SERIAL `equals to:`CREATE SEQUENCE *name*; CREATE TABLE *table* (          *column* INTEGER NOT NULL         DEFAULT nextval(**name**) ); ` | `*column* GENERATED BY DEFAULT `                             | Note for PostgresSQL:SERIAL = 1 – 2147483647 BIGSERIAL = 1 – 9223372036854775807SERIAL is in fact an entity named SEQUENCE. It exists independently on the rest of your table. If you want to cleanup your system after dropping a table, you also have to `DROP SEQUENCE *name*`. [More on that topic...](http://www.sitepoint.com/article/site-mysql-postgresql-1/3)Note for MySQL:`*column* SERIAL PRIMARY KEY `or`*column* SERIAL, PRIMARY KEY(*column*) `Will result in having 2 indexes for *column*. One will be generated by the `PRIMARY KEY` constraint, and one by the implicit `UNIQUE` constraint present in the `SERIAL` alias. This has been reported as a bug and might be corrected. |
| `*column* ENUM (*value1*, *value2*, [...]) `                 | `*column* VARCHAR(255) NOT NULL, CHECK (*column* IN (*value1*, *value2*, [...])) `or`CREATE TYPE mood AS ENUM ('sad','ok','happy'); CREATE TABLE person ( current_mood mood ... ) ` | `*column* VARCHAR(255) NOT NULL, CHECK (*column* IN (*value1*, *value2*, [...])) ` | PostgreSQL doesn't have the ENUM types prior to 8.3, so you need to simulate it with constraints when using < 8.3. |

 